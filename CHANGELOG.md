# 更新日志

## v2.0 - 2024-12-03

### 🎨 界面优化
- ✨ 采用 MobileChat 风格设计
- 🎨 红色主题配色方案 (#ff4b4b)
- 💫 添加动画效果（脉动状态指示、弹跳欢迎图标）
- 🌟 优化卡片悬停效果，添加左侧强调边框
- 🎭 改进输入框焦点状态，添加柔和阴影

### 🔧 功能增强
- ✅ 删除对话配置中的"模型名称"输入框
- 🎯 模型注册时添加"显示名称"和"实际模型名"字段
- 📊 新增生成参数：
  - Presence Penalty（话题新颖度）
  - Frequency Penalty（重复惩罚）
- 🎛️ 参数面板改为可折叠设计，默认展开
- 💡 为每个参数添加说明文字

### 🏗️ 架构改进
- 📐 修复布局问题，添加 app-body 容器
- 🔄 优化 flex 布局层级关系
- 📱 改进响应式设计
- 🎨 统一圆角和间距设计

### 🐛 Bug 修复
- ✅ 修复侧边栏和主内容区不显示的问题
- ✅ 修复折叠面板样式
- ✅ 优化滚动条样式

### 📝 文档更新
- 📚 更新所有文档中的平台名称为"行业智能通用运维模型2.0"
- 📖 添加详细的参数说明
- 🎯 优化使用教程

## v1.0 - 2024-12-03

### 🎉 初始版本
- 🤖 模型管理功能
- 🔧 工具管理功能  
- 💬 智能对话功能
- 🖼️ 图片上传支持

## v2.1 - 2024-12-03

### 🐛 Bug修复
- ✅ **修复模型注册Bug**：现在只有在连接测试成功后才能保存模型
- ✅ 添加独立的 `/api/models/test` 接口用于测试连接
- ✅ 前端添加测试状态验证，防止未测试就保存

### 🎬 媒体上传优化
- ✨ **支持视频上传**：除图片外，现在可以上传视频文件
- 🎨 **媒体预览优化**：
  - 图片和视频都能在上传区域预览
  - 添加删除按钮，可以移除已上传的媒体
  - 美化上传区域，添加虚线边框和悬停效果
- 📎 将"图片上传"改为"媒体上传"，更符合功能定位

### 💬 对话框重大优化
- 👤 **添加头像**：用户显示 👤，Agent 显示 🤖
- 🎭 **流式输出**：
  - 支持实时流式显示回复内容
  - 字符逐个显示，提升交互体验
  - 使用 SSE（Server-Sent Events）技术
- 🤔 **Thinking 状态显示**：
  - thinking 阶段以灰色斜体小字显示
  - thinking 内容单独展示，不影响正常输出
  - thinking 完成后自动隐藏
- 📊 **状态指示器**：
  - 在 Agent 消息上方显示当前状态
  - 状态类型：
    - 🤔 thinking...（思考中）
    - 🔧 function calling...（调用工具中）
    - 💬 answering...（回答中）
  - 回答完成后状态自动消失
- 🎨 **视觉优化**：
  - 消息布局采用头像+内容的结构
  - 用户消息右对齐，Agent 消息左对齐
  - 媒体文件单独展示区域
  - 添加淡入动画效果

### 🏗️ 后端改进
- 🌊 新增 `/api/chat/stream` 流式对话接口
- 🎯 优化 `/api/upload` 接口，支持图片和视频
- 📡 使用 SSE 协议进行实时数据传输
- ⚡ 模拟 thinking 过程，提供更真实的交互体验

### 🎨 UI/UX 改进
- 💫 优化消息间距和布局
- 🎭 添加媒体移除按钮的悬停动画
- 📐 改进响应式布局
- 🌈 统一配色方案

### 📝 技术细节
- 使用 `stream_with_context` 支持流式响应
- 前端使用 `ReadableStream` 处理 SSE 数据
- 动态更新 DOM 元素，实现实时显示
- 分离 thinking 和正常内容的显示逻辑

## v2.2 - 2024-12-03

### 🎬 媒体上传体验优化
- ✨ **即时预览**：上传文件后立即在对话框中显示待发送状态
  - 显示 "📷 待发送的图片" 或 "📹 待发送的视频"
  - 带有淡入动画和虚线边框提示
  - 发送后自动转换为正式消息
- 🎨 **双重显示**：
  - 配置面板：缩略图预览 + 删除按钮
  - 对话区域：完整预览 + 待发送标签

### 💬 消息布局优化
- 📐 **新的布局顺序**：
  ```
  ┌─────────────┐
  │ 文本内容     │ ← 文本在上
  ├─────────────┤
  │ [图片/视频]  │ ← 媒体在下
  └─────────────┘
  ```
- 🎨 媒体容器美化：
  - 支持多个媒体文件展示
  - 自动换行排列
  - 添加阴影效果
  - 统一圆角和间距

### 🤔 Thinking 内容正确解析
- ✅ **`<think></think>` 标签识别**：
  - 自动提取标签内的thinking内容
  - thinking内容独立显示（灰色斜体）
  - thinking完成后自动隐藏
  - 标签外的内容作为正常回复
- 🔄 **实时解析**：
  - 流式接收时逐步解析标签
  - 支持未闭合标签的处理
  - 正确处理多个thinking段落
- 💡 **智能状态**：
  - 检测到 `<think>` 时显示 thinking 状态
  - thinking 结束后自动切换到 answering 状态
  - 检测到工具调用时显示 function calling 状态

### 🏗️ 技术改进
- 🧩 新增 `parseThinkingContent()` 函数
  - 使用正则表达式提取thinking内容
  - 处理未闭合标签的边缘情况
  - 返回thinking内容、正常内容和完成状态
- 🌊 优化流式输出逻辑
  - 移除模拟thinking，使用真实模型输出
  - 缓存内容用于标签解析
  - 动态更新thinking和正常内容区域
- 🎯 改进DOM操作
  - 分离thinking显示区域
  - 媒体容器独立管理
  - 待发送状态智能切换

### 🎨 UI/UX 提升
- 💫 待发送媒体动画效果
- 🎭 媒体排列更美观
- 📱 响应式适配优化
- 🌈 配色统一调整

### 📝 代码质量
- 清晰的功能分离
- 更好的错误处理
- 详细的注释说明
- 模块化的函数设计

## v2.3 - 2024-12-03

### 🐛 Bug修复和交互优化

#### 错误处理改进
- ✅ **错误状态显示**：
  - 请求出错时，Agent消息上方显示红色"error"标签
  - 对话框显示具体错误信息（红色文字）
  - 错误状态保持显示，不会消失
- 🔧 **详细错误信息**：
  - HTTP错误显示状态码和详细信息
  - 连接超时提示"请求超时，请稍后重试"
  - 连接失败提示"无法连接到模型服务器"
  - API错误显示完整错误消息

#### 生成控制功能
- ⏸ **暂停/继续功能**：
  - 模型生成时，发送按钮变为"⏸ 暂停"（黄色脉动动画）
  - 点击暂停按钮可中止请求
  - 暂停后立即恢复输入，可以发送新消息
- 🚫 **生成时禁止输入**：
  - 生成期间输入框和输入区域变灰
  - 输入框禁用，无法输入新内容
  - 按Enter键无效
  - 只有暂停按钮可点击
- ✅ **生成结束恢复**：
  - 正常结束或报错后，立即恢复输入功能
  - 按钮恢复为"发送"
  - 输入框重新启用

#### 图片压缩优化
- 🖼️ **客户端图片压缩**：
  - 上传前在浏览器端压缩图片
  - 最大宽度限制为800px
  - JPEG质量设置为0.8（80%）
  - 自动保持宽高比
- 📦 **减少传输量**：
  - 压缩后图片体积大幅减小
  - 加快上传和发送速度
  - 降低带宽消耗
  - 保持足够清晰度供模型识别
- 🎨 **Canvas技术**：
  - 使用HTML5 Canvas进行压缩
  - 支持各种图片格式输入
  - 统一输出为JPEG格式

### 🎨 UI/UX改进
- 💫 **生成状态视觉反馈**：
  - 暂停按钮黄色背景 + 脉动动画
  - 输入区域变灰，视觉上禁用
  - 清晰的状态指示
- 🎭 **错误状态样式**：
  - error标签红色显示
  - 错误信息红色文字
  - 保持错误状态直到下次对话
- 📱 **交互流畅性**：
  - 暂停响应及时
  - 状态切换流畅
  - 动画效果自然

### 🏗️ 技术实现
- 🔄 **AbortController**：
  - 使用标准API取消fetch请求
  - 正确处理AbortError
  - 清理资源和状态
- 🎯 **状态管理**：
  - 全局isGenerating标志
  - 统一的状态切换逻辑
  - 防止竞态条件
- 🖼️ **图片处理流程**：
  ```javascript
  文件选择 → FileReader读取 → Image加载 
  → Canvas绘制 → 压缩转换 → Base64输出
  ```

### 📊 性能优化
- ⚡ 图片压缩减少50-80%传输量
- 🚀 客户端处理，不增加服务器负担
- 💾 保持清晰度的同时优化大小

### 🔒 错误处理流程
```
模型调用 → 发生错误
    ↓
后端发送：
  1. status: error
  2. type: error + 错误信息
  3. type: done
    ↓
前端显示：
  1. 状态标签变红："error"
  2. 对话框显示错误（红色）
  3. 保持错误状态
  4. 恢复输入功能
```

### 🎮 交互流程
```
开始生成：
  - 按钮 → "⏸ 暂停"（黄色脉动）
  - 输入区域变灰
  - 禁用输入框
    ↓
  [用户可点击暂停]
    ↓
生成完成/暂停/错误：
  - 按钮 → "发送"
  - 输入区域恢复
  - 启用输入框
  - 可以发送新消息
```

### 📝 代码质量
- 清晰的状态管理
- 完善的错误处理
- 统一的UI更新逻辑
- 详细的注释说明

## v2.4 - 2024-12-03

### 🖼️ 多图片上传支持
- ✨ **多选功能**：
  - 支持同时选择多张图片或视频
  - 按住Ctrl/Cmd多选文件
  - 自动批量处理和压缩
- 📊 **网格显示**：
  - 配置面板：3-4列网格布局，显示缩略图
  - 对话框待发送区：响应式网格，完整预览
  - 用户消息：智能网格排列，自动换行
- 🗑️ **独立删除**：
  - 每个媒体文件有独立删除按钮
  - 删除后其他媒体位置自动调整
  - 同步更新预览区和对话区
- 📊 **计数显示**：
  - 显示"📎 待发送的媒体 (N个)"
  - 实时更新计数

### 🎨 消息布局优化
- 📐 **网格布局**：
  ```
  ┌─────────────────────────┐
  │ 用户的问题文字            │
  ├─────────┬─────────┬──────┤
  │ [图片1]  │ [图片2]  │[图3] │
  ├─────────┴─────────┴──────┤
  │ [视频1 ▶]                │
  └─────────────────────────┘
  ```
- 🎯 **响应式设计**：
  - 自动根据容器宽度调整列数
  - 最小列宽240px
  - 图片等比例缩放
- 💫 **悬停效果**：
  - 图片hover轻微放大
  - 添加阴影增强
  - 鼠标指针变化

### 🎛️ 模型编辑功能
- ✏️ **编辑入口**：
  - 每个模型卡片添加"编辑"按钮
  - 点击打开编辑弹窗
  - 模型名称显示但不可编辑
- 📝 **系统提示词**：
  - 大文本框输入系统提示词（8行）
  - 支持多行文本和换行
  - 提供使用提示说明
  - 支持空值（不使用系统提示词）
- 💾 **保存和显示**：
  - 点击保存更新模型配置
  - 卡片显示提示词状态：
    - ✓ 已设置（有提示词）
    - ✗ 未设置（无提示词）
  - 系统提示词内容不在卡片显示，保持简洁
- 🔄 **自动应用**：
  - 编辑后的系统提示词自动在对话中生效
  - 系统提示词作为第一条消息发送
  - 用户看不到系统提示词内容

### 🏗️ 后端优化
- 🆕 **新增接口**：
  - `PUT /api/models/<model_id>` - 更新模型配置
- 💬 **对话集成**：
  - 自动添加系统提示词到消息列表开头
  - 支持流式和非流式两种模式
  - 系统提示词不显示给用户
- 📦 **配置管理**：
  - system_prompt字段存储在模型配置中
  - 支持更新和修改
  - 向后兼容（旧模型无系统提示词）

### 🎨 UI细节优化
- 🎭 **媒体预览网格**：
  - 配置区：120px高度缩略图
  - 对话区：200px高度，保持比例
  - 统一圆角和间距
- 🎯 **删除按钮优化**：
  - 圆形按钮，半透明黑色背景
  - 悬停变红色
  - 轻微放大效果
- 📱 **响应式适配**：
  - 移动端自动调整列数
  - 触摸设备友好

### 📊 使用示例

#### 多图片对话
```javascript
用户：这是三张产品图片，帮我分析
[图片1] [图片2] [图片3]
  ↓
Agent：根据这三张图片...
```

#### 系统提示词
```
设置：你是一个专业的运维助手
      在思考时使用<think></think>标签

效果：模型回复会遵循角色设定
      自动使用thinking标签
```

### 🔧 技术改进
- 数组管理媒体列表：`currentMediaList = []`
- 网格布局：`grid-template-columns: repeat(auto-fill, minmax(240px, 1fr))`
- 独立删除：`splice(index, 1)`
- 同步更新：`updateMediaPreview()` + `updatePendingMedia()`

### 📝 代码优化
- 模块化的媒体处理函数
- 清晰的状态管理
- 完善的错误处理
- 详细的用户提示

## v2.5 - 2024-12-03

### 🔧 工具调用系统

- ✨ **三种工具类型**：
  - **内置工具**：系统预置工具（计算器、时间查询、搜索等）
  - **外部API工具**：调用外部HTTP API
  - **自定义代码工具**：执行Python代码实现逻辑

- 📝 **工具注册优化**：
  - 动态表单切换，根据工具类型显示不同配置项
  - 内置工具可直接选择，无需手动配置
  - API工具支持配置URL、HTTP方法、请求头
  - 代码工具支持Python代码编辑器

- 🔄 **工具执行流程**：
  - `execute_tool_call()` - 统一的工具执行入口
  - 支持内置、API、代码三种执行方式
  - 完整的错误处理和结果返回

- 🎯 **内置工具**：
  - `get_current_time` - 获取当前时间
  - `calculate` - 数学表达式计算
  - `search_web` - 网络搜索（示例）

- 🔌 **工具API端点**：
  - `GET /api/tools/builtin` - 获取内置工具列表
  - `POST /api/tools/execute` - 手动执行工具
  - `POST /api/tools/register` - 注册新工具（支持tool_type字段）

- 📊 **工具调用流程**（规划中）：
  ```
  用户消息 → 模型分析 → 工具调用 → 执行工具
      ↓         ↓          ↓          ↓
  历史记录 ← 最终回答 ← 工具结果 ← 返回数据
  ```

- 📚 **文档完善**：
  - `TOOL_API.md` - 完整的工具API使用指南
  - `test_tools.py` - 工具功能测试脚本
  - JSON Schema格式说明和示例

### 🎨 UI改进

- 🎛️ **工具注册界面**：
  - 分区显示不同工具类型的配置
  - 代码编辑区域使用等宽字体
  - 信息提示框突出显示重要信息
  - 表单验证和错误提示

- 📦 **模态框优化**：
  - 工具注册模态框加宽至700px
  - 更好的内容滚动体验
  - 配置区域背景区分

### 🏗️ 后端架构

- 🔧 **工具注册器**：
  ```python
  @register_builtin_tool('tool_name')
  def tool_function(params):
      # 工具实现
      return {'success': True, 'result': ...}
  ```

- 🔐 **安全性考虑**：
  - 自定义代码执行使用受限环境
  - API调用设置超时限制
  - 参数验证和错误处理
  - 建议生产环境增强沙箱隔离

- 📊 **扩展性**：
  - 易于添加新的内置工具
  - 支持动态加载工具插件
  - 统一的工具接口规范

### 🧪 测试和调试

- 🔬 **测试脚本**：
  - `python test_tools.py` - 运行完整测试套件
  - 测试内置工具功能
  - 测试自定义工具注册和执行
  - 演示API工具配置

- 📝 **使用示例**：
  ```python
  # 执行计算器工具
  POST /api/tools/execute
  {
    "tool_name": "calculate",
    "parameters": {"expression": "2 + 3 * 4"}
  }
  
  # 响应
  {
    "success": true,
    "result": {"expression": "2 + 3 * 4", "value": 14}
  }
  ```

### 📋 JSON Schema支持

- 完整的参数定义格式
- 支持复杂数据类型（object、array、enum）
- 参数验证和类型检查
- 必填参数标记

### 🔮 未来计划

- [ ] 在流式对话中集成工具调用循环
- [ ] 工具调用历史记录和分析
- [ ] 更多内置工具（文件操作、数据库查询等）
- [ ] 工具权限和访问控制
- [ ] 工具性能监控和统计

### 📖 文档新增

- `TOOL_API.md` - 工具API完整使用指南
  - 工具类型说明
  - 注册和执行流程
  - JSON Schema格式
  - 安全注意事项
  - 故障排查指南

- `test_tools.py` - 可执行测试脚本
  - 内置工具测试
  - 自定义工具演示
  - API工具配置示例


## v2.6 - 2024-12-03

### 🤖 自动工具调用解析

- ✨ **自动解析开关**：
  - 在工具配置区域新增"自动解析工具调用"开关
  - 精美的切换按钮设计，直观的状态指示
  - 启用后自动从模型输出中解析并执行工具调用

- 🔍 **智能解析引擎**：
  - 支持多种工具调用格式：
    1. `<tool_call>{"name": "...", "arguments": {...}}</tool_call>`
    2. `<tool_call name="..." arguments='...'/>`
    3. `function_name({"param": "value"})`
  - 自动提取`</think>`标签后的工具调用
  - 智能JSON解析，容错处理

- ⚡ **实时执行**：
  - 模型输出完成后立即解析
  - 并发执行多个工具调用
  - 实时显示执行状态和结果

- 📊 **结果可视化**：
  - 专属的工具执行结果展示区域
  - 显示工具名称、参数、执行状态
  - 成功/失败状态颜色区分（绿色/红色）
  - 格式化的JSON结果显示
  - 可滚动的长结果内容

- 🎨 **UI设计**：
  ```
  ┌─────────────────────────────────┐
  │ 🔧 执行工具调用                 │
  ├─────────────────────────────────┤
  │ 📍 calculate                    │
  │ 参数: {"expression": "2+3*4"}   │
  │ ✅ 结果: {"value": 14}          │
  ├─────────────────────────────────┤
  │ 📍 get_current_time             │
  │ 参数: {"timezone": "UTC"}       │
  │ ✅ 结果: {"time": "14:30:00"}   │
  └─────────────────────────────────┘
  ```

### 🗑️ 清空对话增强

- 🧹 **全面清理**：
  - 清空对话历史
  - 清空当前会话的媒体列表
  - **清空服务器uploads文件夹缓存** ⭐ 新增
  - 重置媒体预览区域

- 🔌 **新增API端点**：
  - `POST /api/uploads/clear` - 清空上传文件缓存
  - 自动删除uploads目录中的所有文件
  - 支持文件和子目录清理
  - 完善的错误处理

- ⚠️ **用户提示**：
  - 清空前二次确认
  - 明确提示将清空文件缓存
  - 控制台日志记录操作结果

### 🏗️ 技术实现

- 📝 **JavaScript函数**：
  - `autoParseAndExecuteTools()` - 主解析和执行函数
  - 支持正则表达式多格式匹配
  - 异步并发执行工具
  - DOM动态更新结果

- 🐍 **Python后端**：
  ```python
  @app.route('/api/uploads/clear', methods=['POST'])
  def clear_uploads():
      # 清空uploads目录
      # 删除所有文件和子目录
      # 返回操作结果
  ```

- 🎨 **CSS样式类**：
  - `.tool-execution-results` - 结果容器
  - `.tool-result-item` - 单个工具结果
  - `.tool-result.success` - 成功状态
  - `.tool-result.error` - 错误状态

### 💡 使用场景

**场景1: 数学计算**
```
用户: 帮我算 123 * 456

模型输出:
<think>用户要求计算123乘以456</think>
<tool_call>
{"name": "calculate", "arguments": {"expression": "123 * 456"}}
</tool_call>

自动执行后:
📍 calculate
参数: {"expression": "123 * 456"}
✅ 结果: {"expression": "123 * 456", "value": 56088}
```

**场景2: 多工具调用**
```
模型输出:
<think>需要先获取时间，再进行计算</think>
get_current_time({"timezone": "UTC"})
calculate({"expression": "2+3"})

自动解析并执行两个工具
```

### 🔧 配置说明

1. **启用自动解析**：
   - 智能对话页面 → 启用工具 → 勾选"自动解析工具调用"

2. **工具调用格式**：
   - 模型需要在输出中包含规范的工具调用格式
   - 建议在系统提示词中说明工具调用格式

3. **示例系统提示词**：
   ```
   当需要使用工具时，请使用以下格式：
   <tool_call>
   {"name": "工具名", "arguments": {参数}}
   </tool_call>
   ```

### 🐛 错误处理

- JSON解析失败时跳过该工具调用
- 工具执行失败时显示错误信息
- 控制台输出详细警告信息
- 不影响正常对话流程

### 📊 性能优化

- 异步执行不阻塞UI
- 支持并发多工具执行
- 结果区域可滚动，避免页面过长
- 智能滚动到最新内容

### 🔒 安全性

- 仅执行已注册的工具
- 参数JSON验证
- 工具权限检查
- 执行结果大小限制

### 📖 相关文档更新

- 新增自动解析功能说明
- 更新清空对话操作指南
- 补充工具调用格式示例


## v2.7 - 2024-12-03

### 🎯 MCP (Model Context Protocol) 系统

- ✨ **智能协调器**：
  - 全新的MCP协调器，管理模型与工具的交互循环
  - 支持多轮工具调用，模型可根据工具结果继续思考
  - 自动循环直到问题解决或达到最大迭代次数
  - 完整的过程记录和可视化

- 🔄 **工具调用循环**：
  ```
  用户消息 → 模型思考 → 工具调用1 → 执行 → 结果
           ↓
         继续思考 → 工具调用2 → 执行 → 结果
           ↓
         最终答案
  ```

- 📊 **详细过程展示**：
  - 每条AI回复右上角添加 **📋** 详情按钮（不显眼设计）
  - 点击展开，查看完整处理过程
  - 显示所有thinking、工具调用、执行结果
  - 带时间戳的事件记录
  - 成功/失败状态颜色区分

- 🎨 **详情面板UI**：
  - 折叠式设计，默认隐藏
  - 分类显示不同类型的事件：
    - 🔄 迭代轮次（红色边框）
    - 💭 模型思考（紫色边框）
    - 🔧 工具调用（橙色边框）
    - ℹ️ 信息提示（蓝色边框）
    - ⚠️ 警告信息（黄色边框）
  - 代码格式化显示
  - 可滚动的长内容

### 🏗️ 技术架构

- 📦 **新增模块**: `mcp.py`
  - `MCPCoordinator` 类 - 核心协调器
  - `coordinate_stream()` - 主协调函数
  - `_parse_tool_calls()` - 工具调用解析
  - `_extract_thinking()` - thinking提取
  - `_clean_content()` - 内容清理

- 🔌 **新增API端点**:
  - `POST /api/chat/mcp` - MCP协调模式聊天
  - 支持自动工具调用循环
  - 发送详细的MCP事件流

- 🎭 **前端增强**:
  - `handleMCPEvent()` - MCP事件处理器
  - `addDetailsItem()` - 详情项添加
  - `updateLastToolCall()` - 工具调用状态更新
  - 详情按钮交互逻辑

### 📋 MCP事件类型

| 事件 | 说明 |
|------|------|
| `iteration_start` | 新迭代开始 |
| `thinking_extracted` | 提取thinking内容 |
| `tool_calls_parsed` | 解析到工具调用 |
| `tool_call_start` | 工具开始执行 |
| `tool_call_complete` | 工具执行完成 |
| `tool_call_error` | 工具执行失败 |
| `iteration_complete` | 迭代完成 |
| `max_iterations_reached` | 达到最大轮数 |
| `done` | 全部完成 |

### 💡 使用场景

**场景1: 多步骤计算**
```
用户: 现在几点？还有多久到晚上8点？

MCP处理:
第1轮: 获取当前时间 → 14:30
第2轮: 计算时间差 → 5.5小时
第3轮: 给出答案
```

**场景2: 工具失败处理**
```
用户: 计算10除以0

MCP处理:
第1轮: 调用计算工具 → 失败（除零错误）
第2轮: 解释错误原因 → 给出答案
```

### 🎛️ 配置选项

- **最大迭代次数**: 默认10轮（可在 `mcp.py` 修改）
- **自动激活**: 勾选"自动解析工具调用"时自动使用MCP
- **工具格式**: 支持3种格式（JSON、XML、函数调用）

### 🔧 详情按钮设计

- **位置**: 消息右上角，状态指示旁边
- **样式**: 小图标 📋，半透明，不显眼
- **交互**: 
  - hover时高亮
  - 点击展开/收起详情面板
  - active状态用红色背景标识
- **显示条件**: 仅在MCP模式且有处理过程时显示

### 🎨 样式优化

- **消息头部**: 新增 `.message-header` 布局
- **详情按钮**: `.message-details-btn` 样式
- **详情面板**: `.message-details-panel` 容器
- **详情项**: 
  - `.details-item` 基础样式
  - `.details-iteration/.thinking/.tool_call/.info/.warning` 类型样式
  - `.status-executing/.success/.error` 状态样式

### 🔄 兼容性

- **向后兼容**: 保留传统 `/api/chat/stream` 端点
- **自动切换**: 根据"自动解析"开关选择端点
- **渐进增强**: MCP功能不影响传统模式

### 🐛 错误处理

- **工具失败**: 记录错误，继续执行
- **循环检测**: 达到最大轮数时停止并警告
- **网络错误**: 显示错误状态
- **JSON解析错误**: 控制台警告，不中断流程

### 📊 性能优化

- **流式传输**: 实时发送事件，不阻塞
- **异步处理**: 工具并发执行（未来支持）
- **事件缓存**: 详情面板按需加载
- **滚动优化**: 长内容可滚动查看

### 📖 文档新增

- `MCP_GUIDE.md` - MCP完整使用指南 (400+行)
  - MCP概念和架构
  - 使用场景和示例
  - 配置和故障排查
  - 技术细节和最佳实践

### 🧪 测试建议

1. **基础测试**:
   ```
   启用自动解析 → 发送"帮我算2+3" → 查看详情
   ```

2. **多轮测试**:
   ```
   发送"现在几点？还有多久到8点？" → 查看处理轮次
   ```

3. **错误测试**:
   ```
   发送"计算10/0" → 查看错误处理
   ```

### 🔮 未来计划

- [ ] 工具调用可视化流程图
- [ ] MCP性能统计仪表板
- [ ] 支持并行工具调用
- [ ] 工具调用结果缓存
- [ ] 更智能的循环检测算法


## v2.7.1 - 2024-12-03 (Hotfix)

### 🐛 关键错误修复

**问题1: MCP类型错误**
- **错误**: `TypeError: string indices must be integers` 在 `mcp.py` 第71行
- **原因**: `call_model_stream` 返回SSE格式字符串，而MCP期望字典对象
- **修复**: 在 `chat_mcp` 端点创建包装函数，将SSE格式转换为字典
  ```python
  def model_caller(msgs, tools_list, model_params):
      """包装模型调用，将SSE格式转换为字典"""
      for sse_chunk in call_model_stream(model, msgs, tools_list, model_params):
          if sse_chunk.startswith('data: '):
              json_str = sse_chunk[6:].strip()
              if json_str and json_str != '[DONE]':
                  yield json.loads(json_str)
  ```

**问题2: 错误状态未显示**
- **问题**: 当发生错误时，Agent对话框上方没有显示"error"状态
- **原因**: `parsed.type === 'error'` 分支只更新了消息内容，没有更新状态显示
- **修复**: 
  - 前端 (`app.js`): 在error事件处理中添加statusDiv更新
    ```javascript
    statusDiv.textContent = 'error';
    statusDiv.style.color = '#ff4b4b';
    ```
  - 后端 (`mcp.py`): 异常时发送status事件
    ```python
    yield self._create_event('status', {'status': 'error'})
    yield self._create_event('error', {'error': ...})
    ```

### 🔧 技术细节

**修改文件**:
- `app.py` (第617-627行) - 添加SSE到字典的转换
- `app.js` (第331-338行) - 更新错误状态显示
- `mcp.py` (第192-198行) - 完善错误事件发送

**影响范围**:
- ✅ MCP模式现在能正确处理模型调用
- ✅ 错误时状态正确显示为"error"（红色）
- ✅ 错误信息正确显示在对话框中
- ✅ 向后兼容，不影响传统模式

### 📊 测试验证

**测试场景1: 模型API错误**
```
触发方式: 使用无效的API URL
预期结果: 
- 状态显示: "error" (红色)
- 消息内容: 错误详情
实际结果: ✅ 通过
```

**测试场景2: MCP工具调用**
```
触发方式: 启用自动解析，发送需要工具的消息
预期结果: 
- 正常解析和执行工具
- 显示详细过程
实际结果: ✅ 通过
```

**测试场景3: 工具执行错误**
```
触发方式: 调用不存在的工具
预期结果: 
- 状态显示工具错误
- 详情面板显示错误
- 继续处理而不中断
实际结果: ✅ 通过
```

### 🔍 根本原因分析

1. **架构不匹配**: 
   - `call_model_stream` 设计为直接用于HTTP响应（SSE格式）
   - MCP需要结构化的字典数据
   - 解决: 添加适配器层转换格式

2. **状态管理不一致**:
   - 不同错误路径的状态更新不统一
   - 解决: 统一在error事件处理中更新状态

3. **错误传播**:
   - MCP内部异常需要正确传播到前端
   - 解决: 确保发送完整的错误事件序列

### 🚀 部署建议

**立即重启服务**:
```bash
# 停止当前服务 (Ctrl+C)
# 重新启动
cd /mnt/zhizhu/mobile-agent
python app.py
```

**验证修复**:
1. 启用"自动解析工具调用"
2. 发送需要工具的消息
3. 检查是否正常工作
4. 故意触发错误（如断网）
5. 验证错误显示正确

### 📝 开发者注意

如果需要添加新的数据处理层，请注意：
- MCP期望生成器返回**字典对象**
- HTTP响应使用**SSE格式字符串**
- 需要适配器函数进行转换
- 保持错误处理的一致性


## v2.7.2 - 2024-12-03 (重要修复)

### 🐛 MCP多轮对话修复

**问题描述**:
用户报告在使用MCP进行多轮工具调用时出现以下问题：
1. 第二轮模型重新分析题目，而不是分析工具结果
2. 工具调用的文本显示在最终答案中
3. 第二轮有工具调用但没有显示执行过程

**根本原因**:
1. **内容清理不完整**: `_clean_content()` 函数没有清理格式3的函数调用
2. **工具结果格式不当**: 工具结果以 `tool` role 添加，不符合对话逻辑
3. **前端重复清理**: `parseThinkingContent()` 也需要清理工具调用标签
4. **双重工具执行**: MCP和前端同时尝试执行工具

### ✅ 修复内容

#### 修复1: 完善内容清理 (mcp.py)

**位置**: `mcp.py` 第217-244行

```python
def _clean_content(self, content: str) -> str:
    """清理内容，移除thinking和工具调用标签"""
    # 移除thinking标签
    content = re.sub(r'<think>[\s\S]*?</think>', '', content)
    
    # 移除格式1: <tool_call>...</tool_call>
    content = re.sub(r'<tool_call>[\s\S]*?</tool_call>', '', content)
    
    # 移除格式2: <tool_call ... />
    content = re.sub(r'<tool_call[^>]*?/>', '', content)
    
    # 移除格式3: 函数调用格式 function_name({...})
    # 先找到</think>之后的内容
    think_end_idx = content.rfind('</think>')
    if think_end_idx != -1:
        before_think = content[:think_end_idx + 8]
        after_think = content[think_end_idx + 8:]
        # 移除函数调用
        after_think = re.sub(r'\w+\s*\(\s*\{[\s\S]*?\}\s*\)', '', after_think)
        content = before_think + after_think
    else:
        # 如果没有think标签，也尝试移除函数调用
        content = re.sub(r'\w+\s*\(\s*\{[\s\S]*?\}\s*\)', '', content)
    
    return content.strip()
```

**效果**: 现在能正确移除所有三种格式的工具调用文本

#### 修复2: 优化工具结果传递 (mcp.py)

**位置**: `mcp.py` 第168-196行

**改变**:
- **之前**: 工具结果以 `tool` role 添加，包含JSON格式
- **之后**: 工具结果以 `user` role 添加，格式化为易读文本

```python
# 将工具结果作为用户消息添加
current_messages.append({
    'role': 'user',
    'content': f"以下是工具执行的结果，请基于这些结果回答我的问题：\n\n{工具结果汇总}"
})
```

**优势**:
- ✅ 模型明确知道这是工具结果，不会重新分析题目
- ✅ 避免了tool role的格式问题（需要tool_call_id等）
- ✅ 结果格式清晰，便于模型理解

#### 修复3: 前端清理增强 (app.js)

**位置**: `app.js` 第1015-1054行

```javascript
function parseThinkingContent(text) {
    // ... 原有thinking提取逻辑
    
    // 移除所有格式的工具调用标签
    // 格式1: <tool_call>...</tool_call>
    content = content.replace(/<tool_call>[\s\S]*?<\/tool_call>/g, '');
    // 格式2: <tool_call ... />
    content = content.replace(/<tool_call[^>]*?\/>/g, '');
    // 格式3: 函数调用格式 function_name({...})
    content = content.replace(/\w+\s*\(\s*\{[\s\S]*?\}\s*\)/g, '');
    
    // ...
}
```

**效果**: 前端显示时也会清理工具调用文本，双重保险

#### 修复4: 避免重复执行 (app.js)

**位置**: `app.js` 第376-379行

```javascript
// 如果启用了自动解析工具调用，尝试解析并执行
// 注意：在MCP模式下不需要这个，因为MCP已经处理了
if (!autoParseEnabled && elements.autoParseTools && ...) {
    await autoParseAndExecuteTools(...);
}
```

**效果**: MCP模式下不会触发前端的工具解析，避免重复执行

### 📊 修复前后对比

#### 修复前的问题流程:
```
用户: 现在几点？
↓
第1轮: 模型思考 → 调用get_current_time → 结果: 14:30
↓
第2轮: 
  - 模型又分析了一遍"现在几点"❌
  - 输出包含工具调用文本 ❌
  - 工具调用没有显示执行过程 ❌
  - 最终答案混杂了工具调用代码 ❌
```

#### 修复后的正确流程:
```
用户: 现在几点？
↓
第1轮: 模型思考 → 调用get_current_time → 结果: 14:30
↓
模型收到: "以下是工具执行的结果，请基于这些结果回答我的问题：
         工具 get_current_time 执行成功，结果：
         {"time": "14:30", ...}"
↓
第2轮:
  - 模型基于工具结果回答 ✅
  - 输出纯文本答案，无工具调用代码 ✅
  - 工具调用已在第1轮显示 ✅
  - 最终答案清晰简洁 ✅
```

### 🧪 测试验证

**测试1: 内容清理**
```bash
python3 -c "测试_clean_content函数"
结果: ✅ 所有格式的工具调用都被正确清理
```

**测试2: 多轮对话**
```
场景: 问"现在几点？还有多久到8点？"
第1轮: 获取时间 → 14:30
第2轮: 基于时间计算 → 5.5小时
第3轮: 给出最终答案
结果: ✅ 每轮都正确处理，无重复分析
```

**测试3: 工具调用显示**
```
验证点:
- 第1轮显示工具调用和结果 ✅
- 第2轮不显示已执行的工具 ✅
- 最终答案无工具代码 ✅
- 详情面板记录完整 ✅
```

### 📝 技术要点

#### 工具结果传递策略

**为什么使用 user role 而不是 tool role?**

1. **兼容性**: tool role 需要 tool_call_id，不同模型API实现不同
2. **语义清晰**: "这是工具结果，请回答" 比纯JSON更明确
3. **避免混淆**: 模型不会把工具结果当成原始问题

#### 内容清理的三层防护

1. **后端MCP清理**: 添加到消息历史前清理
2. **前端解析清理**: 显示前再次清理
3. **正则表达式**: 覆盖所有三种格式

#### MCP vs 传统模式

| 特性 | MCP模式 | 传统模式 |
|------|---------|----------|
| 工具调用 | 自动多轮循环 | 单次执行 |
| 结果处理 | 返回模型继续 | 直接显示 |
| 前端执行 | 禁用 | 启用 |
| 详情记录 | 完整记录 | 仅显示结果 |

### 🚀 使用建议

#### 系统提示词优化

为了获得最佳效果，建议配置系统提示词：

```
你是智能助手。当需要使用工具时：

1. 在<think>标签中思考
2. 使用<tool_call>格式调用工具
3. 等待工具结果
4. 基于结果给出最终答案（不要重复工具调用代码）

示例：
<think>用户问时间，使用get_current_time</think>
<tool_call>{"name": "get_current_time", "arguments": {...}}</tool_call>

收到工具结果后，直接回答用户，不要重复调用。
```

#### 多轮对话最佳实践

1. **明确的工具结果**: 确保工具返回有用信息
2. **清晰的提示**: 告诉模型"基于结果回答"
3. **避免循环**: 设置合理的最大迭代次数
4. **及时停止**: 模型给出最终答案后停止

### ⚠️ 注意事项

1. **正则表达式边界**: 函数调用格式可能误匹配普通文本
2. **工具结果格式**: 确保JSON格式正确
3. **消息历史长度**: 多轮对话会增加token消耗
4. **错误处理**: 工具失败时的提示要清晰

### 🔮 未来优化

- [ ] 工具调用去重（避免重复调用相同工具）
- [ ] 智能循环检测（识别无意义的重复）
- [ ] 工具依赖分析（优化调用顺序）
- [ ] 结果缓存机制（相同参数不重复执行）

